# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright 2015-2016 by EcpyPulses Authors, see AUTHORS for more details.
#
# Distributed under the terms of the BSD license.
#
# The full license is in the file LICENCE, distributed with this software.
# -----------------------------------------------------------------------------
"""View of the task used to transfer a pulse sequence on an arbitrary
waveform generator.

"""
from __future__ import (division, unicode_literals, print_function,
                        absolute_import)
import os
import logging
from traceback import format_exc
from textwrap import fill

from enaml.layout.api import factory, hbox, vbox, spacer
from enaml.core.api import Conditional, Include
from enaml.widgets.api import (GroupBox, Label, Field, ObjectCombo, CheckBox,
                               Notebook, Page, PushButton, Menu, Action,
                               FileDialogEx, Container)
from enaml.stdlib.message_box import information, question

from ecpy.utils.widgets.qt_completers import QtLineCompleter
from ecpy.utils.widgets.dict_editor import DictEditor
from ecpy.tasks.tasks.instr_view import InstrTaskView

from ecpy_pulses.pulses.utils.entry_eval import EVALUATER_TOOLTIP
from ecpy_pulses.pulses.utils.sequences_io import save_sequence_prefs
from ecpy_pulses.pulses.sequences.views.base_sequences_views\
     import instantiate_context_view


enamldef VarEditor(Container):
    """ Fields allowing top edit the global variables of a sequence.

    """
    #: Modle object describing the key/value pair.
    attr model

    padding = 1
    constraints = [hbox(lab, val)]
    Label: lab:
        hug_width = 'strong'
        text << model.key
    QtLineCompleter: val:
        text := model.value
        entries_updater << model.task.list_accessible_database_entries
        tool_tip = EVALUATER_TOOLTIP


def validate_context_driver_pair(core, context, task, parent=None):
    """Validate that the context can work in conjunction with the selected
    driver.

    """
    if task.selected_instrument and task.selected_instrument[0]:
        cmd = 'ecpy.pulses.get_context_infos'
        c_id = context.context_id
        c_infos = core.invoke_command(cmd, dict(context_id=c_id))
        driver_id = task.selected_instrument[1]
        if driver_id not in c_infos.instruments:
            del task.selected_instrument
            information(parent, title='Invalid context/driver association',
                        text=fill('The context of the loaded sequence does '
                                  'not support the selected driver, please '
                                  ' elect a different driver.'))


def load_sequence(core, task, parent=None, path=''):
    """Open a dialog and load a pulse sequence.

    Parameters
    ----------
    core : CorePlugin
        Refrence to the core plugin of the application.
    task : TransferPulseSequenceTask
        Task for which to load the sequence.
    parent : enaml.Widget
        Parent for the dialog.
    path : unicode, optional
        Path of the sequence to load. If this does not point to a real
        file the path is used as a hint for the file selection dialog.

    """
    if not os.path.isfile(path):
        path = FileDialogEx.get_open_file_name(parent, path=path,
                                               name_filters=['*.pulse.ini'])
    if path:
        cmd = 'ecpy.pulses.build_sequence'
        try:
            seq = core.invoke_command(cmd, {'path': path})
        except Exception:
            cmd = 'ecpy.app.errors.signal'
            msg = 'Failed to load sequence {}: {}'.format(path, format_exc())
            core.invoke_command(cmd, dict(kind='error', message=msg))
            return

        if seq.context:
            validate_context_driver_pair(core, seq.context, task, parent)

        task.sequence = seq
        added = set(seq.external_vars) - set(task.sequence_vars)
        removed = set(task.sequence_vars) - set(seq.external_vars)
        seq_vars = task.sequence_vars.copy()
        for e in added:
            seq_vars[e] = ''
        for e in removed:
            del seq_vars[e]
        task.sequence_vars = seq_vars
        task.sequence_path = path
        task.sequence_timestamp = os.path.getmtime(path)


enamldef TransferPulseSequenceView(InstrTaskView): view:
    """View for the TransferPulseSequenceTask.

    """
    constraints = [vbox(hbox(seq, seq_name, seq_re, seq_sav, spacer,
                             instr_label, instr_selection),
                        *cnd.items)]

    initialized ::

        task.observe('sequence', _install_context_observer)

        if task.sequence:
            if os.path.getmtime(task.sequence_path) != task.sequence_timestamp:
                seq_re.background = 'red'
                seq_re.tool_tip = fill('The sequence appears to have been '
                                       'edited since it has been reload. '
                                       'Consider refreshing the sequence.')

            if task.sequence.context:
                validate_context_driver_pair(root.core, task.sequence.context,
                                             task, self)

            task.sequence.observe('context',
                                  _check_context_driver_compatibility)

    filter_profiles => (profiles):
        """Only allow profile whose at least one driver can be used by the
        context.

        """
        if not task.sequence or not task.sequence.context:
            return profiles

        cmd = 'ecpy.pulses.get_context_infos'
        c_id = task.sequence.context.context_id
        c_infos = self.root.core.invoke_command(cmd, dict(context_id=c_id))

        return [p for p, v in profiles.items()
                if any([d.id in c_infos.instruments
                        for d in v.model.drivers])]

    filter_drivers => (drivers):
        """Only allow drivers supported by the context.

        """
        if not task.sequence or not task.sequence.context:
            return profiles

        cmd = 'ecpy.pulses.get_context_infos'
        c_id = task.sequence.context.context_id
        c_infos = self.root.core.invoke_command(cmd, dict(context_id=c_id))

        return [d for d in drivers if d.id in c_infos.instruments]

    instr_selection.enabled << bool(task.sequence and task.sequence.context)
    instr_selection.tool_tip << ('Please first select a context'
                                if not instr_selection.enabled else
                                '')

    PushButton: seq:
        enabled << bool(task.selected_instrument and
                        task.selected_instrument[0])
        text = 'Select sequence'
        clicked ::
            dir_path = os.path.dirname(task.sequence_path)
            load_sequence(view.root.core, task, parent=view, path=dir_path)

    Field: seq_name:
        visible << bool(task.sequence_path)
        read_only = True
        text << os.path.basename(task.sequence_path).rstrip('.pulse.ini')

    PushButton: seq_re:
        enabled << bool(task.sequence_path)
        text = 'Refresh'
        clicked ::
            btn = question(self, title='Confirm refresh',
                           text='If you refresh any local modification to the '
                                'sequence will be lost.\nConfirm refresh ?')
            if btn and btn.action == 'accept':
                load_sequence(view.root.core, task, path=task.sequence_path)
                self.tool_tip = 'Reload the sequence from file.'

    PushButton: seq_sav:
        enabled << bool(task.sequence_path)
        text = 'Save'
        clicked ::
            btn = question(self, title='Confirm save',
                           text='If you save any local modification will '
                                'override the original sequence.\n'
                                'Confirm save ?')
            if btn and btn.action == 'accept':
                seq = task.sequence
                prefs = seq.preferences_from_members()
                prefs['external_vars'] = repr(dict.fromkeys(seq.external_vars,
                                                            '')
                                              )
                save_sequence_prefs(task.sequence_path, prefs)
                task.sequence_timestamp = os.path.getmtime(task.sequence_path)

    Conditional: cnd:
        condition << bool(task.sequence)
        Notebook:
            tabs_closable = False
            Page:
                title = 'Variables (Name: values)'
                DictEditor(VarEditor): ed:
                    ed.mapping = task.sequence_vars
                    ed.attributes = {'task': task}
            Page:
                title = 'Context'
                Include:
                    objects << ([instantiate_context_view(view.root.core,
                                                          task.sequence.context
                                                          )]
                                if task.sequence.context else [])

    # =========================================================================
    # --- Private API ---------------------------------------------------------
    # =========================================================================

    func _install_context_observer(change):
        """Setup an observer to validate the driver/context match on context
        change.

        """
        if 'oldvalue' in change and change['oldvalue']:
            change['oldvalue'].unobserve('context',
                                         _check_context_driver_compatibility)
        if change['value']:
            sequence = change['value']
            sequence.observe('context', _check_context_driver_compatibility)
            if sequence.context:
                validate_context_driver_pair(view.root.core,
                                             task.sequence.context, task, view)

    func _check_context_driver_compatibility(change):
        """Check whether the selected driver can be used with the selected
        context.

        """
        if task.sequence.context:
            validate_context_driver_pair(view.root.core, task.sequence.context,
                                         task, view)
