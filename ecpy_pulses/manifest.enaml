# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright 2015-2016 by EcpyPulses Authors, see AUTHORS for more details.
#
# Distributed under the terms of the BSD license.
#
# The full license is in the file LICENCE, distributed with this software.
# -----------------------------------------------------------------------------
"""Plugin handling the generation and compilation and of sequences of pulses, 
and defining some default pulse shapes.

"""
from __future__ import (division, unicode_literals, print_function,
                        absolute_import)

from ast import literal_eval
from future.builtins import str
from configobj import ConfigObj
from copy import deepcopy

from enaml.workbench.api import PluginManifest, Extension, ExtensionPoint
from enaml.workbench.core.api import Command
from enaml.workbench.ui.api import ActionItem, MenuItem, ItemGroup

from ecpy.app.api import AppStartup
from ecpy.app.preferences.api import Preferences
from ecpy.app.states.api import State
from ecpy.app.dependencies.api import BuildDependency, RuntimeDependencyAnalyser
from ecpy.utils.plugin_tools import make_handler

from ecpy.app.errors.widgets import (ErrorsDialog, BasicErrorsDisplay)
from ecpy.measure.workspace.checks_display import ChecksDisplay
from .utils.flatten_config import flatten_config

from .widgets.building import BuilderView, ContextBuilderView
from .utils.sequences_io import load_sequence_prefs
from .sequences.base_sequences import (AbstractSequence, BaseSequence,
                                       RootSequence)
from .sequences.conditional_sequence import ConditionalSequence
from .sequences.views.base_sequence_view import (BaseSequenceView,
                                                 RootSequenceView)
from .sequences.views.conditional_view import ConditionalSequenceView
from .sequences.template_sequence import TemplateSequence
from .sequences.views.template_view import TemplateSequenceView

from .filters.base_filters import (ItemFilter, SequenceFilter, TemplateFilter,
                                   SubclassItemFilter, MetadataItemFilter)

from .declarations import (Sequences, Sequence, SequenceConfigs, 
                           SequenceConfig, Contexts, Context, Shapes, Shape)


PLUGIN_ID = 'ecpy.pulses'


# =============================================================================
# --- Factories ---------------------------------------------------------------
# =============================================================================

def manager_plugin_factory():
    """ Factory funcion for the task manager plugin.

    """
    from .plugin import PulsesManagerPlugin
    return PulsesManagerPlugin()

def workspace_factory(workbench):
    from .workspace.workspace import SequenceEditionSpace
    return SequenceEditionSpace()

# =============================================================================
# --- Command Handlers --------------------------------------------------------
# =============================================================================

# TODO implement a true manager
#def show_manager(event):
#    """ Handler for the 'ecpy.instr_manager.show_manager' command
#
#    """
#    manager = event.workbench.get_plugin('ecpy')
#    from .manager_view import TaskManagerView
#    TaskManagerView(manager=manager).show()

def show_starting_errors(event):
    """ Handler for the 'ecpy.pulses.show_errors' command.

    """
    manager = event.workbench.get_plugin('ecpy.pulses')
    ui = event.workbench.get_plugin('enaml.workbench.ui')
    rep = manager.report()
    if rep:
        ChecksDisplay(ui.window, title='Pulses manager start up errors',
                      errors=manager.report()).exec_()
    else: #TODO ???? should be a dialog
        #BasicErrorsDisplay(ui.window, #title='Pulses manager start up errors',
        #              errors=manager.report()).exec_()
        ChecksDisplay(ui.window, title='Pulses manager start up errors',
                      errors=manager.report()).exec_()

def get_sequences_infos(event):
    """ Handler for the 'ecpy.pulses.get_sequence_info' command.

    """
    manager = event.workbench.get_plugin('ecpy.pulses')
    return manager.get_sequences_infos(**event.parameters)

def get_sequence_info(event):
    """ Handler for the 'ecpy.pulses.get_sequence_info' command.

    """
    manager = event.workbench.get_plugin('ecpy.pulses')
    return manager.get_sequence_info(**event.parameters)

def get_sequences(event):
    """ Handler for the 'ecpy.pulses.get_sequence' command.

    """
    manager = event.workbench.get_plugin('ecpy.pulses')
    return manager.get_sequences(**event.parameters)

def get_sequence(event):
    """ Handler for the 'ecpy.pulses.get_sequence' command.

    """
    manager = event.workbench.get_plugin('ecpy.pulses')
    return manager.get_sequence(**event.parameters)

def get_items_infos(event):
    """ Handler for the 'ecpy.pulses.get_sequence' command.

    """
    manager = event.workbench.get_plugin('ecpy.pulses')
    return manager.get_items_infos(**event.parameters)

def get_contexts_infos(event):
    """ Handler for the 'ecpy.pulses.get_contexts_infos' command.

    """
    manager = event.workbench.get_plugin('ecpy.pulses')
    return manager.get_contexts_infos(**event.parameters)

def get_context_info(event):
    """ Handler for the 'ecpy.pulses.get_context_info' command.

    """
    manager = event.workbench.get_plugin('ecpy.pulses')
    return manager.get_context_info(**event.parameters)

def get_shapes_infos(event):
    """ Handler for the 'ecpy.pulses.get_shapes_infos' command.

    """
    manager = event.workbench.get_plugin('ecpy.pulses')
    return manager.get_shapes_infos(**event.parameters)

def build_sequence(event):
    """ Handler for the 'ecpy.pulses.build_sequence' command.

    Parameters
    ----------
    mode : {'ui', 'file'}
        Should the command open a dialog to select a sequence (ui), or should
        it build a RootSequence from the given ressource.

    root : RootSequence, optional
        RootSequence in which to insert the new sequence once built (ui mode
        only).

    path : unicode, optional
        Path to the file holding the sequence config. The stored sequence
        should be a RootSequence not a TemplateSequence. Used in file mode.

    prefs : dict, optional
        Sequence config describing the sequence to rebuilf. The stored sequence
        should be a RootSequence not a TemplateSequence. Used in file mode.

    Returns
    -------
    sequence : BaseSequence

    """
    manager = event.workbench.get_plugin('ecpy.pulses')
    mode = event.parameters.get('mode')
    if mode == 'ui':
        parent_ui = event.parameters.get('parent_ui')
        root = event.parameters['root']
        dial = BuilderView(parent_ui, manager=manager, root=root)
        dial.exec_()
        if dial.result:
            seq = dial.model.sequence_config.build_sequence()
            if seq:
                return seq
            else:
                BasicErrorsDisplay(errors=dial.model.sequence_config.errors,
                                   kind='Config errors').exec_()

    elif mode == 'file':
        if 'path' in event.parameters:
            prefs = ConfigObj(event.parameters['path'])
        elif 'prefs' in event.parameters:
            prefs = event.parameters['prefs']
        else:
            raise ValueError('No valid kwargs found for file mode')
        # Implement the logic here to rebuild the sequence.
        core = manager.workbench.get_plugin('enaml.workbench.core')
        cmd = 'ecpy.app.dependencies.collect_build_dep_from_config'
        dep = core.invoke_command(cmd, {'config': prefs})
        if isinstance(dep, Exception):
            raise dep

        seq = RootSequence.build_from_config(deepcopy(prefs), dep)
        return seq


def build_context(event):
    """ Select a context for a given pulse sequence.

    """
    manager = event.workbench.get_plugin('ecpy.pulses')
    parent_ui = event.parameters.get('parent_ui')
    root = event.parameters['root']
    dial = ContextBuilderView(parent_ui, manager=manager)
    dial.exec_()
    if dial.result:
        root.context = dial.context()

# =============================================================================
# --- Descriptions ------------------------------------------------------------
# =============================================================================

SHOW_MANAGER_DESCRIPTION = \
""" Show the task manager window."""

SHOW_ERRORS_DESCRIPTION = \
""" Show the errors which happened on plugin startup."""

CONTEXTS_REQUEST_DESCRIPTION = \
""" Request the infos associated to a list of contexts. """

GET_SHAPES_INFOS_DESCRIPTION = \
""" Request the infos associated to a list of shapes. """

BUILD_SEQUENCE_DESCRIPTION = \
""" Build a sequence from the one knwon to the plugin."""

BUILD_CONTEXT_DESCRIPTION = \
""" Build a context for the given root sequence."""

MANAGER_STATE_DESCRIPTION = \
""" The tasks manager gives access to the known tasks and filters."""

FILTERS_DESC =\
"""Filters are used when listing the items known to the application. Filters
must inherit from one of the base classes found in filters.py.

"""

SEQUENCES_DESC_DESC =\
"""Sequences are the way used to register new sequences. Please
refer to the different kind of declarations defined in declarations.py for
more details.

"""


SHAPES_DESC_DESC =\
"""Shapes are the way used to register new sequences. Please
refer to the different kind of declarations defined in declarations.py for
more details.

"""

CONFIGS_DESC =\
"""Configs are used when new sequences or pulses need to be inserted into a
config hierarchy at runtime. They provide a way for the user to parametrize the
config before inserting it into the hierarchy. See declarations.py for more 
infos about how to declare a new config.

"""

CONTEXTS_DESC =\
"""Configs are used when new sequences or pulses need to be inserted into a
context hierarchy at runtime. They provide a way for the user to parametrize 
the context before inserting it into the hierarchy. See declarations.py for 
more infos about how to declare a new config.

"""

GET_SEQUENCES_INFOS_DESCRIPTION =\
"""Retrieve the infos object associated with a sequence given the 
name of the sequence.

Parameters
----------
sequence_cls_name : unicode
    Name of the sequence class name for which to retrieve the infos.

Returns
-------
infos : SequenceInfos|None
    Infos for the requested sequence or None if no matching sequence was found.

"""

GET_SEQUENCE_INFOS_DESCRIPTION =\
"""Retrieve the infos object associated with a sequence given the 
name of the sequence.

Parameters
----------
sequence_cls_name : unicode
    Name of the sequence class name for which to retrieve the infos.

Returns
-------
infos : SequenceInfos|None
    Infos for the requested sequence or None if no matching sequence was found.

"""


# =============================================================================
# --- ???????????? ------------------------------------------------------------
# =============================================================================

# TODO Fix from get_sequnces_infos
# TODO add protection againt recursive ones.
def collect_pulses_dependecies(workbench, flat_walk):
    """ Collector function for the build-dependencies extensions.

    """
    # Here we use direct call to plugin methods as this is internal to the
    # plugin
    manager = workbench.get_plugin('ecpy.pulses')

    # Collect items.
    s_res = manager.get_sequences_infos(flat_walk['item_class'],
                                      use_class_names=True,
                                      views=False)
    # Collect contexts.
    c_res = manager.get_contexts_infos(flat_walk['context_class'],
                                     use_class_names=True,
                                     views=False)
    # Collect shapes.
    sh_res = manager.get_shapes_infos(flat_walk['shape_class'],
                                      use_class_names=True,
                                      views=False)

    # Collect the templates.
    tp_res = manager.get_sequences_infos(flat_walk['template_id'])

    # Collect the sequences.
    sq_res = {p: load_sequence_prefs(p)[0] for p in flat_walk['sequence_path']
              if p}

    if s_res[1] or c_res[1] or sh_res[1] or tp_res[1]:
        mess = 'Missing sequences: {}, contexts: {}, shapes: {}, templates: {}'

        raise ValueError(mess.format(s_res[1], c_res[1], sh_res[1], tp_res[1]))

    # Bundle all dependencies under a single dict.
    dependencies = {}
    dependencies.update(s_res[0])
    dependencies['contexts'] = c_res[0]
    dependencies['shapes'] = sh_res[0]
    dependencies['templates'] = tp_res[0]
    dependencies['sequences'] = sq_res

    # Collect template dependencies.
    for _, conf, _ in tp_res[0]:
        t_conf = flatten_config(conf, ['item_class', 'context_class',
                                       'shape_class', 'template_id'])
        t_dep = collect_pulses_dependecies(workbench, t_conf)['pulses']
        t_dep.pop('sequences')
        dependencies['shapes'].update(t_dep.pop('shapes'))
        dependencies['contexts'].update(t_dep.pop('contexts'))
        dependencies['templates'].update(t_dep.pop('templates'))
        dependencies.update(t_dep)

    # NB : no nesting possible for pulse sequences.
    for conf in sq_res.values():
        s_conf = flatten_config(conf, ['item_class', 'context_class',
                                       'shape_class', 'template_id'])
        s_dep = collect_pulses_dependecies(workbench, s_conf)['pulses']
        s_dep.pop('sequences')
        dependencies['shapes'].update(s_dep.pop('shapes'))
        dependencies['contexts'].update(s_dep.pop('contexts'))
        dependencies['templates'].update(s_dep.pop('templates'))
        dependencies.update(s_dep)

    if dependencies:
        return {'pulses': dependencies}
    else:
        return {}


# =============================================================================
# --- Manifest ----------------------------------------------------------------
# =============================================================================

enamldef PulsesManagerManifest(PluginManifest):
    """Manifest declaring the extension points to Ecpy.

    """
    id = PLUGIN_ID
    factory = manager_plugin_factory


    # =========================================================================
    # --- Startup Extension ----------------------------------------------------
    # =========================================================================

    Extension:
        point = 'ecpy.app.startup'
        AppStartup:
            id = 'ecpy.pulses'
            run => (workbench, cmd_args):
                print('The Ecpy_Pulses plugin has been loaded.')


    # =========================================================================
    # --- Extension points ----------------------------------------------------
    # =========================================================================
    
    ExtensionPoint:
        id = 'sequences'
        description = SEQUENCES_DESC

    ExtensionPoint:
        id = 'shapes'
        description = SHAPES_DESC

    ExtensionPoint:
        id = 'configs'
        description = CONFIGS_DESC

    ExtensionPoint:
        id = 'contexts'
        description = CONTEXTS_DESC

    ExtensionPoint:
        id = 'filters'
        description = FILTERS_DESC

    # =========================================================================
    # --- Extensions ----------------------------------------------------------
    # =========================================================================

    #: Filters
    Extension:
        id = 'filters'
        point = 'ecpy.pulses.filters'
        ItemFilter:
            id = 'All'
        SequenceFilter:
            id = 'Sequences'
        TemplateFilter:
            id = 'Templates'

    Extension:
        id = 'sequences'
        point = 'ecpy.pulses.sequences'
        Sequences:
            path = 'ecpy_pulses.sequences'
            Sequence:
                sequence = 'base_sequences:BaseSequence'
                view = 'views.base_sequence_view:BaseSequenceView'
            Sequence:
                sequence = 'conditional_sequence:ConditionalSequence'
                view = 'views.conditional_view:ConditionalSequenceView'

    Extension:
        id = 'configs'
        point = 'ecpy.pulses.configs'
        SequenceConfigs:
            path = 'ecpy_pulses.configs'
            SequenceConfig:
                config = 'base_config:SequenceConfig'
                view = 'base_config_views:SequenceConfigView'
                get_sequence_class => ():
                    from ecpy_pulses.sequences.base_sequences import (
                        BaseSequence)
                    return BaseSequence
            SequenceConfig:
                config = 'template_config:TemplateConfig'
                view = 'template_config_view:TemplateConfigView'
                get_sequence_class => ():
                    return '__template__'

    Extension:
        id = 'contexts'
        point = 'ecpy.pulses.contexts'
        Contexts:
            path = 'ecpy_pulses.contexts'
            Context:
                context = 'awg_context:AWGContext'
                view = 'views.awg_context_view:AWGContextView'
            Context:
                context = 'tabor_context:TABORContext'
                view = 'views.tabor_context_view:TaborContextView'
            Context:
                context = 'template_context:TemplateContext'
                view = 'views.template_context_view:TemplateContextView'


    Extension:
        id = 'shapes'
        point = 'ecpy.pulses.shapes'
        Shapes:
            path = 'ecpy_pulses.shapes'
            Shape:
                shape = 'square_shape:SquareShape'
                view = 'views.square_shape_view:SquareShapeView'

    #Ported
    Extension:
        id = 'prefs'
        point = 'ecpy.app.preferences.plugin'
        Preferences:
            pass

    #Ported
    Extension:
        id = 'state'
        point = 'ecpy.app.states.state'
        State:
            id = 'ecpy.pulses'
            description = MANAGER_STATE_DESCRIPTION
            sync_members = ['sequences', 'contexts', 'shapes']

    #ToPort
    #Extension:
    #    id = 'item_classes'
    #    point = 'ecpy.app.dependencies.build'
    #    BuildDependency:
    #        id = 'ecpy.pulses.dependencies'
    #        walk_members = ['item_class', 'context_class',
    #                        'shape_class', 'template_id',
    #                        'sequence_path']
    #        collect = collect_pulses_dependecies

    #Ported
    Extension:
        id = 'workspace'
        point = u'enaml.workbench.ui.workspaces'
        factory = workspace_factory

    #ToCheck
    Extension:
        id = 'commands'
        point = 'enaml.workbench.core.commands'
#        Command:
#            id = 'ecpy.instr_manager.show_manager'
#            description = SHOW_MANAGER_DESCRIPTION
#            handler = show_manager
        Command:
            id = 'ecpy.pulses.show_starting_errors'
            description = SHOW_ERRORS_DESCRIPTION
            handler = show_starting_errors
        Command:
            id = 'ecpy.pulses.get_sequences_infos'
            description = GET_SEQUENCE_INFOS_DESCRIPTION
            handler = get_sequences_infos
        Command:
            id = 'ecpy.pulses.get_sequence_info'
            description = GET_SEQUENCE_INFOS_DESCRIPTION
            handler = get_sequence_info
        Command:
            id = 'ecpy.pulses.get_sequences'
            description = GET_SEQUENCES_INFOS_DESCRIPTION
            handler = get_sequences
        Command:
            id = 'ecpy.pulses.get_sequence'
            description = GET_SEQUENCE_INFOS_DESCRIPTION
            handler = get_sequence
        Command:
            id = 'ecpy.pulses.get_items_infos'
            description = GET_SEQUENCE_INFOS_DESCRIPTION
            handler = get_items_infos
        Command:
            id = 'ecpy.pulses.get_contexts_infos'
            description = "HELLO"
            handler = get_contexts_infos
        Command:
            id = 'ecpy.pulses.get_context_info'
            description = "HELLO"
            handler = get_context_info
        Command:
            id = 'ecpy.pulses.get_shapes_infos'
            description = GET_SHAPES_INFOS_DESCRIPTION
            handler = get_shapes_infos
        Command:
            id = 'ecpy.pulses.build_sequence'
            description = BUILD_SEQUENCE_DESCRIPTION
            handler = build_sequence
        Command:
            id = 'ecpy.pulses.build_context'
            description = BUILD_CONTEXT_DESCRIPTION
            handler = build_context

    #Checked
    Extension:
        id = 'menu'
        point = 'enaml.workbench.ui.actions'
        MenuItem:
            path = '/tools/pulses'
            label = 'Pulses'
#            after = 'tasks'
            ItemGroup:
                id = 'user'
#        ActionItem:
#            path = '/tasks/show_manager'
#            label = 'Manager'
#            command = 'ecpy.task_manager.show_manager'
        ActionItem:
            path = 'tools/pulses/show_errors'
            label = 'Start up errors'
            command = 'ecpy.pulses.show_starting_errors'
        ActionItem:
                path = '/workspace/pulses'
                label = 'Pulses'
                shortcut = 'Ctrl+3'
#                after = 'debug'
                group = 'spaces'
                command = 'enaml.workbench.ui.select_workspace'
                parameters = {'workspace': 'ecpy.pulses.workspace'}
